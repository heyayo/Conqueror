#include "Levelmid1.hpp"
#include "Door.hpp"
#include "Player.hpp"
#include "Maths.hpp"
#include "DeadSoul.hpp"
#include "Wall.hpp"
#include "Melee.hpp"
#include "HPcrystal.hpp"
#include "Atkgem.hpp"
#include <string>
#include "Bar.hpp"
#include "TextBox.hpp"
#include "Chest.hpp"
#include "AtkToken.hpp"
#include "DefToken.hpp"
#include <random>


Physical* wallmid1[2];
Door* toNextLevelmid1;
Player* playermid1;
DeadSoul* speakermid1;
Atkgem* Atkgem1[3];
HPcrystal* HPcrystal1[3];
AtkToken* AtkToken1;
DefToken* DefToken1;
Chest* Chest1;
TextBox* Statusmid1;
std::string stm1[8];
bool chestopen = false;
bool gem1open = false;
bool gem2open = false;
bool gem3open = false;
bool gem4open = false;

int random(int x, int y) {
    //generate uniformly distributed numbers
    std::random_device generator;
    //transform sequences of numbers generated by generator
    std::mt19937 rng(generator());
    std::uniform_int_distribution< std::mt19937::result_type> random(x, y);
    //generate number in the given range x-y
    return random(generator);
}

void Levelmid1::LoadScene()
{
    SaveState temp = LoadSave();
    chestopen = false;
    gem1open = false;
    gem2open = false;
    gem3open = false;
    gem4open = false;
    SetBG("SceneBG/stage middle.png", V2(1920, 1080));
    toNextLevelmid1 = new Door;
    switch (temp.currentLevel) {
    case LEVELONE :
        toNextLevelmid1->Redirect(LEVELTWO);
        break;
    case LEVELTWO:
        toNextLevelmid1->Redirect(LEVELTHREE);
        break;
    case LEVELTHREE:
        toNextLevelmid1->Redirect(LEVELFOUR);
        break;
    case LEVELFOUR:
        toNextLevelmid1->Redirect(LEVELFIVE);
        break;
    }
    toNextLevelmid1->SetPosition(1500, 500);

    playermid1 = new Player;
    playermid1->SetPosition(100, 350);

    

    Chest1 = new Chest;
    Chest1->SetPosition(1100, 600);
  
    DefToken1 = new DefToken;
    DefToken1->SetPosition(10000, 500);

    AtkToken1 = new AtkToken;
    AtkToken1->SetPosition(10000, 500);


    HPcrystal1[1] = new HPcrystal;
    HPcrystal1[1]->SetPosition(10000, 500);
    Atkgem1[1] = new Atkgem;
    Atkgem1[1]->SetPosition(10000, 500);

    HPcrystal1[0] = new HPcrystal;
    HPcrystal1[0]->SetPosition(10000, 500);
    Atkgem1[0] = new Atkgem;
    Atkgem1[0]->SetPosition(10000, 500);

    HPcrystal1[2] = new HPcrystal;
    HPcrystal1[2]->SetPosition(10000, 500);
    Atkgem1[2] = new Atkgem;
    Atkgem1[2]->SetPosition(10000, 500);

    wallmid1[0] = new Wall;
    wallmid1[0]->SetCollisionSize(V2(350, 1000));
    wallmid1[0]->SetPosition(250, 950);
    wallmid1[0]->Init({0,0,0,0}, V2(550, 300));
    wallmid1[1] = new Wall;
    wallmid1[1]->SetCollisionSize(V2(180, 240));
    wallmid1[1]->SetPosition(250, 120);
    wallmid1[1]->Init({0,0,0,0}, V2(550, 300));

    stm1[0] = "Journals Collected";
    stm1[1] = std::to_string(temp.JournalCount);
    stm1[2] = "Armour :";
    stm1[3] = std::to_string(temp.armour);
    stm1[4] = "HP :";
    stm1[5] = std::to_string(temp.health);
    stm1[6] = "DMG :";
    stm1[7] = std::to_string(temp.damage);
    Statusmid1 = new TextBox(stm1,8);
    Statusmid1->SetPosition(GetScreenCenter());
    Statusmid1->SetFontSize(30);
    Statusmid1->SetPadding(V2(300, 300));
    Statusmid1->SetAlignment(TextBox::CENTER);
    AddUI(Statusmid1);

    AddPhysical(playermid1);
    AddPhysical(toNextLevelmid1);
    AddPhysical(wallmid1[0]);
    AddPhysical(wallmid1[1]);

    AddPhysical(Chest1);

    AddPhysical(AtkToken1);
    AddPhysical(DefToken1);

    AddPhysical(HPcrystal1[0]);
    AddPhysical(Atkgem1[0]);
    AddPhysical(HPcrystal1[1]);
    AddPhysical(Atkgem1[1]);
    AddPhysical(HPcrystal1[2]);
    AddPhysical(Atkgem1[2]);
}

void Levelmid1::SceneUpdate()
{
    Statusmid1->SetVisibility(IsKeyDown(KEY_I));
    // DEBUG OPTION, MOUSE LEFT PRINTS OUT LOCATION IN SPACE
    if (IsMouseButtonPressed(MOUSE_BUTTON_LEFT))
    {
        std::cout << Maths::ConvertToV2(GetMousePosition()) << std::endl;
    }
}

void Levelmid1::Collision()
{
    SaveState temp = LoadSave();
    if (Chest1 != nullptr)
    {
        if (CalculateCollisionsBetween(playermid1, Chest1))
        {
            Kill(Chest1);
            if (chestopen == false) {
                std::cout << "COLL" << std::endl;
                int var = random(1, 2);
                if (var == 2) {
                    HPcrystal1[1]->SetPosition(1000, 500);
                }
                else {
                    Atkgem1[1]->SetPosition(1000, 500);
                }
                var = random(1, 2);
                if (var == 2) {
                    HPcrystal1[0]->SetPosition(1200, 500);
                }
                else {
                    Atkgem1[0]->SetPosition(1200, 500);
                }
                var = random(1, 2);
                if (var == 2) {
                    HPcrystal1[2]->SetPosition(1200, 700);
                }
                else {
                    Atkgem1[2]->SetPosition(1200, 700);
                }
                var = random(1, 2);
                if (var == 2) {
                    AtkToken1->SetPosition(1000, 700);
                }
                else {
                    DefToken1->SetPosition(1000, 700);
                }
                chestopen = true;
            }
        }
   
    }

    if (Atkgem1[0] != nullptr)
    {
        if (CalculateCollisionsBetween(playermid1, Atkgem1[0]))
        {
            Kill(Atkgem1[0]);
            if (gem1open == false) {
                gem1open = true;
                playermid1->boostspeed(0.5);
            }
        }
    }
    if (Atkgem1[1] != nullptr)
    {
        if (CalculateCollisionsBetween(playermid1, Atkgem1[1]))
        {
            Kill(Atkgem1[1]);
            if (gem2open == false) {
                gem2open = true;
                playermid1->boostspeed(0.5);
            }
        }
    }
    if (Atkgem1[2] != nullptr)
    {
        if (CalculateCollisionsBetween(playermid1, Atkgem1[2]))
        {
            Kill(Atkgem1[2]);
            if (gem3open == false) {
                gem3open = true;
                playermid1->boostspeed(0.5);
            }
        }
    }

    if (HPcrystal1[0] != nullptr)
    {
        if (CalculateCollisionsBetween(playermid1, HPcrystal1[0]))
        {
            Kill(HPcrystal1[0]);
            if (gem1open == false) {
                gem1open = true;
                playermid1->Heal(50);
            }
        }
    }
    if (HPcrystal1[1] != nullptr)
    {
        if (CalculateCollisionsBetween(playermid1, HPcrystal1[1]))
        {
            Kill(HPcrystal1[1]);
            if (gem2open == false) {
                gem2open = true;
                playermid1->Heal(50);
            }
        }
    }
    if (HPcrystal1[2] != nullptr)
    {
        if (CalculateCollisionsBetween(playermid1, HPcrystal1[2]))
        {
            Kill(HPcrystal1[2]);
            if (gem3open == false) {
                gem3open = true;
                playermid1->Heal(50);
            }
        }
    }

    if (AtkToken1 != nullptr)
    {
        if (CalculateCollisionsBetween(playermid1, AtkToken1))
        {
            Kill(AtkToken1);
            if (gem4open == false) {
                gem4open = true;
                playermid1->boostdmg();
            }
        }
    }
    if (DefToken1 != nullptr)
    {
        if (CalculateCollisionsBetween(playermid1, DefToken1))
        {
            Kill(DefToken1);
            if (gem4open == false) {
                gem4open = true;
                playermid1->boostdef(3);
            }
        }
    }

    for (auto walls : wallmid1)
        if (CalculateCollisionsBetween(playermid1, walls))
            playermid1->Move(-playermid1->GetVelocity());

    // playermid1 Collision With Border
    if (CalculateCollisionBorder(playermid1))
        playermid1->Move(-playermid1->GetVelocity());

    // Enemy Collision With Arrows
    std::vector<Actor*> arrows = GetActorsByGroup("PROJECTILE");
    std::vector<Actor*> enemyList1 = GetActorsByGroup("ENEMY");

    // Enemy Collisions
    for (auto arrow : arrows)
    {
        // Kill Arrow on Border Collision
        if (CalculateCollisionBorder(arrow))
        {
            Kill(arrow);
            std::cout << "BORDER HIT" << std::endl;
        }
        else {
            for (auto walle : wallmid1)
            {
                if (CalculateCollisionsBetween(walle, arrow))
                    Kill(arrow);
                std::cout << "WALL HIT" << std::endl;
            }
        }
    }
    std::vector<Physical*> melee = GetPhysicsByGroup("MELEE");
    for (auto mel : melee)
    {
        Melee* temp = static_cast<Melee*>(mel);
        if (temp->cooldown >= temp->maxCooldown)
            Kill(mel);
        for (auto e : enemyList1)
        {
            {
            if (CalculateCollisionsBetween(e, mel))
                e->Hurt(temp->GetDamage());
            }
        }
    }
}
